// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/localization/proto/localization_status.proto
// Protobuf Java Version: 4.26.1

package apollo.localization;

public final class LocalizationStatus {
  private LocalizationStatus() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 26,
      /* patch= */ 1,
      /* suffix= */ "",
      LocalizationStatus.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * LiDAR-based loclaization module status
   * </pre>
   *
   * Protobuf enum {@code apollo.localization.LocalLidarStatus}
   */
  public enum LocalLidarStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Localization result satisfy threshold
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_NORMAL = 0;</code>
     */
    MSF_LOCAL_LIDAR_NORMAL(0),
    /**
     * <pre>
     * Can't find localization map (config.xml)
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_MAP_MISSING = 1;</code>
     */
    MSF_LOCAL_LIDAR_MAP_MISSING(1),
    /**
     * <pre>
     * Missing extrinsic parameters
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_EXTRINSICS_MISSING = 2;</code>
     */
    MSF_LOCAL_LIDAR_EXTRINSICS_MISSING(2),
    /**
     * <pre>
     * Fail to load localization map
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_MAP_LOADING_FAILED = 3;</code>
     */
    MSF_LOCAL_LIDAR_MAP_LOADING_FAILED(3),
    /**
     * <pre>
     * No output (comparing to timestamp of imu msg)
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_NO_OUTPUT = 4;</code>
     */
    MSF_LOCAL_LIDAR_NO_OUTPUT(4),
    /**
     * <pre>
     * Coverage of online pointcloud and map is lower than threshold
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_OUT_OF_MAP = 5;</code>
     */
    MSF_LOCAL_LIDAR_OUT_OF_MAP(5),
    /**
     * <pre>
     * Localization result do not meet threshold
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_NOT_GOOD = 6;</code>
     */
    MSF_LOCAL_LIDAR_NOT_GOOD(6),
    /**
     * <pre>
     * others
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_UNDEFINED_STATUS = 7;</code>
     */
    MSF_LOCAL_LIDAR_UNDEFINED_STATUS(7),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        LocalLidarStatus.class.getName());
    }
    /**
     * <pre>
     * Localization result satisfy threshold
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_NORMAL = 0;</code>
     */
    public static final int MSF_LOCAL_LIDAR_NORMAL_VALUE = 0;
    /**
     * <pre>
     * Can't find localization map (config.xml)
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_MAP_MISSING = 1;</code>
     */
    public static final int MSF_LOCAL_LIDAR_MAP_MISSING_VALUE = 1;
    /**
     * <pre>
     * Missing extrinsic parameters
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_EXTRINSICS_MISSING = 2;</code>
     */
    public static final int MSF_LOCAL_LIDAR_EXTRINSICS_MISSING_VALUE = 2;
    /**
     * <pre>
     * Fail to load localization map
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_MAP_LOADING_FAILED = 3;</code>
     */
    public static final int MSF_LOCAL_LIDAR_MAP_LOADING_FAILED_VALUE = 3;
    /**
     * <pre>
     * No output (comparing to timestamp of imu msg)
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_NO_OUTPUT = 4;</code>
     */
    public static final int MSF_LOCAL_LIDAR_NO_OUTPUT_VALUE = 4;
    /**
     * <pre>
     * Coverage of online pointcloud and map is lower than threshold
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_OUT_OF_MAP = 5;</code>
     */
    public static final int MSF_LOCAL_LIDAR_OUT_OF_MAP_VALUE = 5;
    /**
     * <pre>
     * Localization result do not meet threshold
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_NOT_GOOD = 6;</code>
     */
    public static final int MSF_LOCAL_LIDAR_NOT_GOOD_VALUE = 6;
    /**
     * <pre>
     * others
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_UNDEFINED_STATUS = 7;</code>
     */
    public static final int MSF_LOCAL_LIDAR_UNDEFINED_STATUS_VALUE = 7;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LocalLidarStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LocalLidarStatus forNumber(int value) {
      switch (value) {
        case 0: return MSF_LOCAL_LIDAR_NORMAL;
        case 1: return MSF_LOCAL_LIDAR_MAP_MISSING;
        case 2: return MSF_LOCAL_LIDAR_EXTRINSICS_MISSING;
        case 3: return MSF_LOCAL_LIDAR_MAP_LOADING_FAILED;
        case 4: return MSF_LOCAL_LIDAR_NO_OUTPUT;
        case 5: return MSF_LOCAL_LIDAR_OUT_OF_MAP;
        case 6: return MSF_LOCAL_LIDAR_NOT_GOOD;
        case 7: return MSF_LOCAL_LIDAR_UNDEFINED_STATUS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LocalLidarStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LocalLidarStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LocalLidarStatus>() {
            public LocalLidarStatus findValueByNumber(int number) {
              return LocalLidarStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(0);
    }

    private static final LocalLidarStatus[] VALUES = values();

    public static LocalLidarStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LocalLidarStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.LocalLidarStatus)
  }

  /**
   * Protobuf enum {@code apollo.localization.LocalLidarQuality}
   */
  public enum LocalLidarQuality
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MSF_LOCAL_LIDAR_VERY_GOOD = 0;</code>
     */
    MSF_LOCAL_LIDAR_VERY_GOOD(0),
    /**
     * <code>MSF_LOCAL_LIDAR_GOOD = 1;</code>
     */
    MSF_LOCAL_LIDAR_GOOD(1),
    /**
     * <code>MSF_LOCAL_LIDAR_NOT_BAD = 2;</code>
     */
    MSF_LOCAL_LIDAR_NOT_BAD(2),
    /**
     * <code>MSF_LOCAL_LIDAR_BAD = 3;</code>
     */
    MSF_LOCAL_LIDAR_BAD(3),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        LocalLidarQuality.class.getName());
    }
    /**
     * <code>MSF_LOCAL_LIDAR_VERY_GOOD = 0;</code>
     */
    public static final int MSF_LOCAL_LIDAR_VERY_GOOD_VALUE = 0;
    /**
     * <code>MSF_LOCAL_LIDAR_GOOD = 1;</code>
     */
    public static final int MSF_LOCAL_LIDAR_GOOD_VALUE = 1;
    /**
     * <code>MSF_LOCAL_LIDAR_NOT_BAD = 2;</code>
     */
    public static final int MSF_LOCAL_LIDAR_NOT_BAD_VALUE = 2;
    /**
     * <code>MSF_LOCAL_LIDAR_BAD = 3;</code>
     */
    public static final int MSF_LOCAL_LIDAR_BAD_VALUE = 3;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LocalLidarQuality valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LocalLidarQuality forNumber(int value) {
      switch (value) {
        case 0: return MSF_LOCAL_LIDAR_VERY_GOOD;
        case 1: return MSF_LOCAL_LIDAR_GOOD;
        case 2: return MSF_LOCAL_LIDAR_NOT_BAD;
        case 3: return MSF_LOCAL_LIDAR_BAD;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LocalLidarQuality>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LocalLidarQuality> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LocalLidarQuality>() {
            public LocalLidarQuality findValueByNumber(int number) {
              return LocalLidarQuality.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(1);
    }

    private static final LocalLidarQuality[] VALUES = values();

    public static LocalLidarQuality valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LocalLidarQuality(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.LocalLidarQuality)
  }

  /**
   * <pre>
   * LiDAR-based localization result check (the difference between lidar and sins
   * result)
   * </pre>
   *
   * Protobuf enum {@code apollo.localization.LocalLidarConsistency}
   */
  public enum LocalLidarConsistency
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * The difference is less than threshold 1
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_00 = 0;</code>
     */
    MSF_LOCAL_LIDAR_CONSISTENCY_00(0),
    /**
     * <pre>
     * The difference is bigger than threshold 1 but less than threshold 2
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_01 = 1;</code>
     */
    MSF_LOCAL_LIDAR_CONSISTENCY_01(1),
    /**
     * <pre>
     * The difference is bigger than threshold 2
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_02 = 2;</code>
     */
    MSF_LOCAL_LIDAR_CONSISTENCY_02(2),
    /**
     * <pre>
     * others
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_03 = 3;</code>
     */
    MSF_LOCAL_LIDAR_CONSISTENCY_03(3),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        LocalLidarConsistency.class.getName());
    }
    /**
     * <pre>
     * The difference is less than threshold 1
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_00 = 0;</code>
     */
    public static final int MSF_LOCAL_LIDAR_CONSISTENCY_00_VALUE = 0;
    /**
     * <pre>
     * The difference is bigger than threshold 1 but less than threshold 2
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_01 = 1;</code>
     */
    public static final int MSF_LOCAL_LIDAR_CONSISTENCY_01_VALUE = 1;
    /**
     * <pre>
     * The difference is bigger than threshold 2
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_02 = 2;</code>
     */
    public static final int MSF_LOCAL_LIDAR_CONSISTENCY_02_VALUE = 2;
    /**
     * <pre>
     * others
     * </pre>
     *
     * <code>MSF_LOCAL_LIDAR_CONSISTENCY_03 = 3;</code>
     */
    public static final int MSF_LOCAL_LIDAR_CONSISTENCY_03_VALUE = 3;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LocalLidarConsistency valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LocalLidarConsistency forNumber(int value) {
      switch (value) {
        case 0: return MSF_LOCAL_LIDAR_CONSISTENCY_00;
        case 1: return MSF_LOCAL_LIDAR_CONSISTENCY_01;
        case 2: return MSF_LOCAL_LIDAR_CONSISTENCY_02;
        case 3: return MSF_LOCAL_LIDAR_CONSISTENCY_03;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LocalLidarConsistency>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LocalLidarConsistency> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LocalLidarConsistency>() {
            public LocalLidarConsistency findValueByNumber(int number) {
              return LocalLidarConsistency.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(2);
    }

    private static final LocalLidarConsistency[] VALUES = values();

    public static LocalLidarConsistency valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LocalLidarConsistency(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.LocalLidarConsistency)
  }

  /**
   * <pre>
   * GNSS-based localization result check (the difference between GNSS and sins
   * result)
   * </pre>
   *
   * Protobuf enum {@code apollo.localization.GnssConsistency}
   */
  public enum GnssConsistency
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * The difference is less than threshold 1
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_00 = 0;</code>
     */
    MSF_GNSS_CONSISTENCY_00(0),
    /**
     * <pre>
     * The difference is bigger than threshold 1 but less than threshold 2
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_01 = 1;</code>
     */
    MSF_GNSS_CONSISTENCY_01(1),
    /**
     * <pre>
     * The difference is bigger than threshold 2
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_02 = 2;</code>
     */
    MSF_GNSS_CONSISTENCY_02(2),
    /**
     * <pre>
     * others
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_03 = 3;</code>
     */
    MSF_GNSS_CONSISTENCY_03(3),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GnssConsistency.class.getName());
    }
    /**
     * <pre>
     * The difference is less than threshold 1
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_00 = 0;</code>
     */
    public static final int MSF_GNSS_CONSISTENCY_00_VALUE = 0;
    /**
     * <pre>
     * The difference is bigger than threshold 1 but less than threshold 2
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_01 = 1;</code>
     */
    public static final int MSF_GNSS_CONSISTENCY_01_VALUE = 1;
    /**
     * <pre>
     * The difference is bigger than threshold 2
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_02 = 2;</code>
     */
    public static final int MSF_GNSS_CONSISTENCY_02_VALUE = 2;
    /**
     * <pre>
     * others
     * </pre>
     *
     * <code>MSF_GNSS_CONSISTENCY_03 = 3;</code>
     */
    public static final int MSF_GNSS_CONSISTENCY_03_VALUE = 3;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static GnssConsistency valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static GnssConsistency forNumber(int value) {
      switch (value) {
        case 0: return MSF_GNSS_CONSISTENCY_00;
        case 1: return MSF_GNSS_CONSISTENCY_01;
        case 2: return MSF_GNSS_CONSISTENCY_02;
        case 3: return MSF_GNSS_CONSISTENCY_03;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<GnssConsistency>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        GnssConsistency> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<GnssConsistency>() {
            public GnssConsistency findValueByNumber(int number) {
              return GnssConsistency.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(3);
    }

    private static final GnssConsistency[] VALUES = values();

    public static GnssConsistency valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private GnssConsistency(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.GnssConsistency)
  }

  /**
   * Protobuf enum {@code apollo.localization.GnssPositionType}
   */
  public enum GnssPositionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * No solution
     * </pre>
     *
     * <code>NONE = 0;</code>
     */
    NONE(0),
    /**
     * <pre>
     * Position has been fixed by the FIX POSITION command or by
     * </pre>
     *
     * <code>FIXEDPOS = 1;</code>
     */
    FIXEDPOS(1),
    /**
     * <pre>
     * position averaging
     * </pre>
     *
     * <code>FIXEDHEIGHT = 2;</code>
     */
    FIXEDHEIGHT(2),
    /**
     * <pre>
     * command or by position averaging
     * </pre>
     *
     * <code>FLOATCONV = 4;</code>
     */
    FLOATCONV(4),
    /**
     * <pre>
     * Solution from wide-lane ambiguities
     * </pre>
     *
     * <code>WIDELANE = 5;</code>
     */
    WIDELANE(5),
    /**
     * <pre>
     * Solution from narrow-lane ambiguities
     * </pre>
     *
     * <code>NARROWLANE = 6;</code>
     */
    NARROWLANE(6),
    /**
     * <pre>
     * Velocity computed using instantaneous Doppler
     * </pre>
     *
     * <code>DOPPLER_VELOCITY = 8;</code>
     */
    DOPPLER_VELOCITY(8),
    /**
     * <pre>
     * Single point position
     * </pre>
     *
     * <code>SINGLE = 16;</code>
     */
    SINGLE(16),
    /**
     * <pre>
     * Pseudorange differential solution
     * </pre>
     *
     * <code>PSRDIFF = 17;</code>
     */
    PSRDIFF(17),
    /**
     * <pre>
     * Solution calculated using corrections from an SBAS
     * </pre>
     *
     * <code>WAAS = 18;</code>
     */
    WAAS(18),
    /**
     * <pre>
     * Propagated by a Kalman filter without new observations
     * </pre>
     *
     * <code>PROPOGATED = 19;</code>
     */
    PROPOGATED(19),
    /**
     * <pre>
     * OmniSTAR VBS position
     * </pre>
     *
     * <code>OMNISTAR = 20;</code>
     */
    OMNISTAR(20),
    /**
     * <pre>
     * Floating L1 albiguity solution
     * </pre>
     *
     * <code>L1_FLOAT = 32;</code>
     */
    L1_FLOAT(32),
    /**
     * <pre>
     * Floating ionospheric free ambiguity solution
     * </pre>
     *
     * <code>IONOFREE_FLOAT = 33;</code>
     */
    IONOFREE_FLOAT(33),
    /**
     * <pre>
     * Floating narrow-lane anbiguity solution
     * </pre>
     *
     * <code>NARROW_FLOAT = 34;</code>
     */
    NARROW_FLOAT(34),
    /**
     * <pre>
     * Integer L1 ambiguity solution
     * </pre>
     *
     * <code>L1_INT = 48;</code>
     */
    L1_INT(48),
    /**
     * <pre>
     * Integer wide-lane ambiguity solution
     * </pre>
     *
     * <code>WIDE_INT = 49;</code>
     */
    WIDE_INT(49),
    /**
     * <pre>
     * Integer narrow-lane ambiguity solution
     * </pre>
     *
     * <code>NARROW_INT = 50;</code>
     */
    NARROW_INT(50),
    /**
     * <pre>
     * RTK status where RTK filter is directly initialized
     * </pre>
     *
     * <code>RTK_DIRECT_INS = 51;</code>
     */
    RTK_DIRECT_INS(51),
    /**
     * <pre>
     * from the INS filter
     * </pre>
     *
     * <code>INS_SBAS = 52;</code>
     */
    INS_SBAS(52),
    /**
     * <pre>
     * INS pseudorange single point solution - no DGPS corrections
     * </pre>
     *
     * <code>INS_PSRSP = 53;</code>
     */
    INS_PSRSP(53),
    /**
     * <pre>
     * INS pseudorange differential solution
     * </pre>
     *
     * <code>INS_PSRDIFF = 54;</code>
     */
    INS_PSRDIFF(54),
    /**
     * <pre>
     * INS RTK float point ambiguities solution
     * </pre>
     *
     * <code>INS_RTKFLOAT = 55;</code>
     */
    INS_RTKFLOAT(55),
    /**
     * <pre>
     * INS RTK fixed ambiguities solution
     * </pre>
     *
     * <code>INS_RTKFIXED = 56;</code>
     */
    INS_RTKFIXED(56),
    /**
     * <pre>
     * INS OmniSTAR VBS solution
     * </pre>
     *
     * <code>INS_OMNISTAR = 57;</code>
     */
    INS_OMNISTAR(57),
    /**
     * <pre>
     * INS OmniSTAR high precision solution
     * </pre>
     *
     * <code>INS_OMNISTAR_HP = 58;</code>
     */
    INS_OMNISTAR_HP(58),
    /**
     * <pre>
     * INS OmniSTAR extra precision solution
     * </pre>
     *
     * <code>INS_OMNISTAR_XP = 59;</code>
     */
    INS_OMNISTAR_XP(59),
    /**
     * <pre>
     * OmniSTAR high precision
     * </pre>
     *
     * <code>OMNISTAR_HP = 64;</code>
     */
    OMNISTAR_HP(64),
    /**
     * <pre>
     * OmniSTAR extra precision
     * </pre>
     *
     * <code>OMNISTAR_XP = 65;</code>
     */
    OMNISTAR_XP(65),
    /**
     * <pre>
     * Precise Point Position(PPP) solution converging
     * </pre>
     *
     * <code>PPP_CONVERGING = 68;</code>
     */
    PPP_CONVERGING(68),
    /**
     * <pre>
     * Precise Point Position(PPP)solution
     * </pre>
     *
     * <code>PPP = 69;</code>
     */
    PPP(69),
    /**
     * <pre>
     * INS NovAtel CORRECT Precise Point Position(PPP)
     * </pre>
     *
     * <code>INS_PPP_Converging = 73;</code>
     */
    INS_PPP_Converging(73),
    /**
     * <pre>
     * solution converging
     * </pre>
     *
     * <code>INS_PPP = 74;</code>
     */
    INS_PPP(74),
    /**
     * <pre>
     * Gnss position message loss
     * </pre>
     *
     * <code>MSG_LOSS = 91;</code>
     */
    MSG_LOSS(91),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        GnssPositionType.class.getName());
    }
    /**
     * <pre>
     * No solution
     * </pre>
     *
     * <code>NONE = 0;</code>
     */
    public static final int NONE_VALUE = 0;
    /**
     * <pre>
     * Position has been fixed by the FIX POSITION command or by
     * </pre>
     *
     * <code>FIXEDPOS = 1;</code>
     */
    public static final int FIXEDPOS_VALUE = 1;
    /**
     * <pre>
     * position averaging
     * </pre>
     *
     * <code>FIXEDHEIGHT = 2;</code>
     */
    public static final int FIXEDHEIGHT_VALUE = 2;
    /**
     * <pre>
     * command or by position averaging
     * </pre>
     *
     * <code>FLOATCONV = 4;</code>
     */
    public static final int FLOATCONV_VALUE = 4;
    /**
     * <pre>
     * Solution from wide-lane ambiguities
     * </pre>
     *
     * <code>WIDELANE = 5;</code>
     */
    public static final int WIDELANE_VALUE = 5;
    /**
     * <pre>
     * Solution from narrow-lane ambiguities
     * </pre>
     *
     * <code>NARROWLANE = 6;</code>
     */
    public static final int NARROWLANE_VALUE = 6;
    /**
     * <pre>
     * Velocity computed using instantaneous Doppler
     * </pre>
     *
     * <code>DOPPLER_VELOCITY = 8;</code>
     */
    public static final int DOPPLER_VELOCITY_VALUE = 8;
    /**
     * <pre>
     * Single point position
     * </pre>
     *
     * <code>SINGLE = 16;</code>
     */
    public static final int SINGLE_VALUE = 16;
    /**
     * <pre>
     * Pseudorange differential solution
     * </pre>
     *
     * <code>PSRDIFF = 17;</code>
     */
    public static final int PSRDIFF_VALUE = 17;
    /**
     * <pre>
     * Solution calculated using corrections from an SBAS
     * </pre>
     *
     * <code>WAAS = 18;</code>
     */
    public static final int WAAS_VALUE = 18;
    /**
     * <pre>
     * Propagated by a Kalman filter without new observations
     * </pre>
     *
     * <code>PROPOGATED = 19;</code>
     */
    public static final int PROPOGATED_VALUE = 19;
    /**
     * <pre>
     * OmniSTAR VBS position
     * </pre>
     *
     * <code>OMNISTAR = 20;</code>
     */
    public static final int OMNISTAR_VALUE = 20;
    /**
     * <pre>
     * Floating L1 albiguity solution
     * </pre>
     *
     * <code>L1_FLOAT = 32;</code>
     */
    public static final int L1_FLOAT_VALUE = 32;
    /**
     * <pre>
     * Floating ionospheric free ambiguity solution
     * </pre>
     *
     * <code>IONOFREE_FLOAT = 33;</code>
     */
    public static final int IONOFREE_FLOAT_VALUE = 33;
    /**
     * <pre>
     * Floating narrow-lane anbiguity solution
     * </pre>
     *
     * <code>NARROW_FLOAT = 34;</code>
     */
    public static final int NARROW_FLOAT_VALUE = 34;
    /**
     * <pre>
     * Integer L1 ambiguity solution
     * </pre>
     *
     * <code>L1_INT = 48;</code>
     */
    public static final int L1_INT_VALUE = 48;
    /**
     * <pre>
     * Integer wide-lane ambiguity solution
     * </pre>
     *
     * <code>WIDE_INT = 49;</code>
     */
    public static final int WIDE_INT_VALUE = 49;
    /**
     * <pre>
     * Integer narrow-lane ambiguity solution
     * </pre>
     *
     * <code>NARROW_INT = 50;</code>
     */
    public static final int NARROW_INT_VALUE = 50;
    /**
     * <pre>
     * RTK status where RTK filter is directly initialized
     * </pre>
     *
     * <code>RTK_DIRECT_INS = 51;</code>
     */
    public static final int RTK_DIRECT_INS_VALUE = 51;
    /**
     * <pre>
     * from the INS filter
     * </pre>
     *
     * <code>INS_SBAS = 52;</code>
     */
    public static final int INS_SBAS_VALUE = 52;
    /**
     * <pre>
     * INS pseudorange single point solution - no DGPS corrections
     * </pre>
     *
     * <code>INS_PSRSP = 53;</code>
     */
    public static final int INS_PSRSP_VALUE = 53;
    /**
     * <pre>
     * INS pseudorange differential solution
     * </pre>
     *
     * <code>INS_PSRDIFF = 54;</code>
     */
    public static final int INS_PSRDIFF_VALUE = 54;
    /**
     * <pre>
     * INS RTK float point ambiguities solution
     * </pre>
     *
     * <code>INS_RTKFLOAT = 55;</code>
     */
    public static final int INS_RTKFLOAT_VALUE = 55;
    /**
     * <pre>
     * INS RTK fixed ambiguities solution
     * </pre>
     *
     * <code>INS_RTKFIXED = 56;</code>
     */
    public static final int INS_RTKFIXED_VALUE = 56;
    /**
     * <pre>
     * INS OmniSTAR VBS solution
     * </pre>
     *
     * <code>INS_OMNISTAR = 57;</code>
     */
    public static final int INS_OMNISTAR_VALUE = 57;
    /**
     * <pre>
     * INS OmniSTAR high precision solution
     * </pre>
     *
     * <code>INS_OMNISTAR_HP = 58;</code>
     */
    public static final int INS_OMNISTAR_HP_VALUE = 58;
    /**
     * <pre>
     * INS OmniSTAR extra precision solution
     * </pre>
     *
     * <code>INS_OMNISTAR_XP = 59;</code>
     */
    public static final int INS_OMNISTAR_XP_VALUE = 59;
    /**
     * <pre>
     * OmniSTAR high precision
     * </pre>
     *
     * <code>OMNISTAR_HP = 64;</code>
     */
    public static final int OMNISTAR_HP_VALUE = 64;
    /**
     * <pre>
     * OmniSTAR extra precision
     * </pre>
     *
     * <code>OMNISTAR_XP = 65;</code>
     */
    public static final int OMNISTAR_XP_VALUE = 65;
    /**
     * <pre>
     * Precise Point Position(PPP) solution converging
     * </pre>
     *
     * <code>PPP_CONVERGING = 68;</code>
     */
    public static final int PPP_CONVERGING_VALUE = 68;
    /**
     * <pre>
     * Precise Point Position(PPP)solution
     * </pre>
     *
     * <code>PPP = 69;</code>
     */
    public static final int PPP_VALUE = 69;
    /**
     * <pre>
     * INS NovAtel CORRECT Precise Point Position(PPP)
     * </pre>
     *
     * <code>INS_PPP_Converging = 73;</code>
     */
    public static final int INS_PPP_Converging_VALUE = 73;
    /**
     * <pre>
     * solution converging
     * </pre>
     *
     * <code>INS_PPP = 74;</code>
     */
    public static final int INS_PPP_VALUE = 74;
    /**
     * <pre>
     * Gnss position message loss
     * </pre>
     *
     * <code>MSG_LOSS = 91;</code>
     */
    public static final int MSG_LOSS_VALUE = 91;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static GnssPositionType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static GnssPositionType forNumber(int value) {
      switch (value) {
        case 0: return NONE;
        case 1: return FIXEDPOS;
        case 2: return FIXEDHEIGHT;
        case 4: return FLOATCONV;
        case 5: return WIDELANE;
        case 6: return NARROWLANE;
        case 8: return DOPPLER_VELOCITY;
        case 16: return SINGLE;
        case 17: return PSRDIFF;
        case 18: return WAAS;
        case 19: return PROPOGATED;
        case 20: return OMNISTAR;
        case 32: return L1_FLOAT;
        case 33: return IONOFREE_FLOAT;
        case 34: return NARROW_FLOAT;
        case 48: return L1_INT;
        case 49: return WIDE_INT;
        case 50: return NARROW_INT;
        case 51: return RTK_DIRECT_INS;
        case 52: return INS_SBAS;
        case 53: return INS_PSRSP;
        case 54: return INS_PSRDIFF;
        case 55: return INS_RTKFLOAT;
        case 56: return INS_RTKFIXED;
        case 57: return INS_OMNISTAR;
        case 58: return INS_OMNISTAR_HP;
        case 59: return INS_OMNISTAR_XP;
        case 64: return OMNISTAR_HP;
        case 65: return OMNISTAR_XP;
        case 68: return PPP_CONVERGING;
        case 69: return PPP;
        case 73: return INS_PPP_Converging;
        case 74: return INS_PPP;
        case 91: return MSG_LOSS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<GnssPositionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        GnssPositionType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<GnssPositionType>() {
            public GnssPositionType findValueByNumber(int number) {
              return GnssPositionType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(4);
    }

    private static final GnssPositionType[] VALUES = values();

    public static GnssPositionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private GnssPositionType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.GnssPositionType)
  }

  /**
   * <pre>
   * IMU msg status
   * </pre>
   *
   * Protobuf enum {@code apollo.localization.ImuMsgDelayStatus}
   */
  public enum ImuMsgDelayStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>IMU_DELAY_NORMAL = 0;</code>
     */
    IMU_DELAY_NORMAL(0),
    /**
     * <code>IMU_DELAY_1 = 1;</code>
     */
    IMU_DELAY_1(1),
    /**
     * <code>IMU_DELAY_2 = 2;</code>
     */
    IMU_DELAY_2(2),
    /**
     * <code>IMU_DELAY_3 = 3;</code>
     */
    IMU_DELAY_3(3),
    /**
     * <code>IMU_DELAY_ABNORMAL = 4;</code>
     */
    IMU_DELAY_ABNORMAL(4),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ImuMsgDelayStatus.class.getName());
    }
    /**
     * <code>IMU_DELAY_NORMAL = 0;</code>
     */
    public static final int IMU_DELAY_NORMAL_VALUE = 0;
    /**
     * <code>IMU_DELAY_1 = 1;</code>
     */
    public static final int IMU_DELAY_1_VALUE = 1;
    /**
     * <code>IMU_DELAY_2 = 2;</code>
     */
    public static final int IMU_DELAY_2_VALUE = 2;
    /**
     * <code>IMU_DELAY_3 = 3;</code>
     */
    public static final int IMU_DELAY_3_VALUE = 3;
    /**
     * <code>IMU_DELAY_ABNORMAL = 4;</code>
     */
    public static final int IMU_DELAY_ABNORMAL_VALUE = 4;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ImuMsgDelayStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ImuMsgDelayStatus forNumber(int value) {
      switch (value) {
        case 0: return IMU_DELAY_NORMAL;
        case 1: return IMU_DELAY_1;
        case 2: return IMU_DELAY_2;
        case 3: return IMU_DELAY_3;
        case 4: return IMU_DELAY_ABNORMAL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ImuMsgDelayStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ImuMsgDelayStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ImuMsgDelayStatus>() {
            public ImuMsgDelayStatus findValueByNumber(int number) {
              return ImuMsgDelayStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(5);
    }

    private static final ImuMsgDelayStatus[] VALUES = values();

    public static ImuMsgDelayStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ImuMsgDelayStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.ImuMsgDelayStatus)
  }

  /**
   * Protobuf enum {@code apollo.localization.ImuMsgMissingStatus}
   */
  public enum ImuMsgMissingStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>IMU_MISSING_NORMAL = 0;</code>
     */
    IMU_MISSING_NORMAL(0),
    /**
     * <code>IMU_MISSING_1 = 1;</code>
     */
    IMU_MISSING_1(1),
    /**
     * <code>IMU_MISSING_2 = 2;</code>
     */
    IMU_MISSING_2(2),
    /**
     * <code>IMU_MISSING_3 = 3;</code>
     */
    IMU_MISSING_3(3),
    /**
     * <code>IMU_MISSING_4 = 4;</code>
     */
    IMU_MISSING_4(4),
    /**
     * <code>IMU_MISSING_5 = 5;</code>
     */
    IMU_MISSING_5(5),
    /**
     * <code>IMU_MISSING_ABNORMAL = 6;</code>
     */
    IMU_MISSING_ABNORMAL(6),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ImuMsgMissingStatus.class.getName());
    }
    /**
     * <code>IMU_MISSING_NORMAL = 0;</code>
     */
    public static final int IMU_MISSING_NORMAL_VALUE = 0;
    /**
     * <code>IMU_MISSING_1 = 1;</code>
     */
    public static final int IMU_MISSING_1_VALUE = 1;
    /**
     * <code>IMU_MISSING_2 = 2;</code>
     */
    public static final int IMU_MISSING_2_VALUE = 2;
    /**
     * <code>IMU_MISSING_3 = 3;</code>
     */
    public static final int IMU_MISSING_3_VALUE = 3;
    /**
     * <code>IMU_MISSING_4 = 4;</code>
     */
    public static final int IMU_MISSING_4_VALUE = 4;
    /**
     * <code>IMU_MISSING_5 = 5;</code>
     */
    public static final int IMU_MISSING_5_VALUE = 5;
    /**
     * <code>IMU_MISSING_ABNORMAL = 6;</code>
     */
    public static final int IMU_MISSING_ABNORMAL_VALUE = 6;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ImuMsgMissingStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ImuMsgMissingStatus forNumber(int value) {
      switch (value) {
        case 0: return IMU_MISSING_NORMAL;
        case 1: return IMU_MISSING_1;
        case 2: return IMU_MISSING_2;
        case 3: return IMU_MISSING_3;
        case 4: return IMU_MISSING_4;
        case 5: return IMU_MISSING_5;
        case 6: return IMU_MISSING_ABNORMAL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ImuMsgMissingStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ImuMsgMissingStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ImuMsgMissingStatus>() {
            public ImuMsgMissingStatus findValueByNumber(int number) {
              return ImuMsgMissingStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(6);
    }

    private static final ImuMsgMissingStatus[] VALUES = values();

    public static ImuMsgMissingStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ImuMsgMissingStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.ImuMsgMissingStatus)
  }

  /**
   * Protobuf enum {@code apollo.localization.ImuMsgDataStatus}
   */
  public enum ImuMsgDataStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>IMU_DATA_NORMAL = 0;</code>
     */
    IMU_DATA_NORMAL(0),
    /**
     * <code>IMU_DATA_ABNORMAL = 1;</code>
     */
    IMU_DATA_ABNORMAL(1),
    /**
     * <code>IMU_DATA_OTHER = 2;</code>
     */
    IMU_DATA_OTHER(2),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        ImuMsgDataStatus.class.getName());
    }
    /**
     * <code>IMU_DATA_NORMAL = 0;</code>
     */
    public static final int IMU_DATA_NORMAL_VALUE = 0;
    /**
     * <code>IMU_DATA_ABNORMAL = 1;</code>
     */
    public static final int IMU_DATA_ABNORMAL_VALUE = 1;
    /**
     * <code>IMU_DATA_OTHER = 2;</code>
     */
    public static final int IMU_DATA_OTHER_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ImuMsgDataStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ImuMsgDataStatus forNumber(int value) {
      switch (value) {
        case 0: return IMU_DATA_NORMAL;
        case 1: return IMU_DATA_ABNORMAL;
        case 2: return IMU_DATA_OTHER;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ImuMsgDataStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ImuMsgDataStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ImuMsgDataStatus>() {
            public ImuMsgDataStatus findValueByNumber(int number) {
              return ImuMsgDataStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(7);
    }

    private static final ImuMsgDataStatus[] VALUES = values();

    public static ImuMsgDataStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ImuMsgDataStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.ImuMsgDataStatus)
  }

  /**
   * <pre>
   * The running status of localization module
   * </pre>
   *
   * Protobuf enum {@code apollo.localization.MsfRunningStatus}
   */
  public enum MsfRunningStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MSF_SOL_LIDAR_GNSS = 0;</code>
     */
    MSF_SOL_LIDAR_GNSS(0),
    /**
     * <code>MSF_SOL_X_GNSS = 1;</code>
     */
    MSF_SOL_X_GNSS(1),
    /**
     * <code>MSF_SOL_LIDAR_X = 2;</code>
     */
    MSF_SOL_LIDAR_X(2),
    /**
     * <code>MSF_SOL_LIDAR_XX = 3;</code>
     */
    MSF_SOL_LIDAR_XX(3),
    /**
     * <code>MSF_SOL_LIDAR_XXX = 4;</code>
     */
    MSF_SOL_LIDAR_XXX(4),
    /**
     * <code>MSF_SOL_X_X = 5;</code>
     */
    MSF_SOL_X_X(5),
    /**
     * <code>MSF_SOL_X_XX = 6;</code>
     */
    MSF_SOL_X_XX(6),
    /**
     * <code>MSF_SOL_X_XXX = 7;</code>
     */
    MSF_SOL_X_XXX(7),
    /**
     * <code>MSF_SSOL_LIDAR_GNSS = 8;</code>
     */
    MSF_SSOL_LIDAR_GNSS(8),
    /**
     * <code>MSF_SSOL_X_GNSS = 9;</code>
     */
    MSF_SSOL_X_GNSS(9),
    /**
     * <code>MSF_SSOL_LIDAR_X = 10;</code>
     */
    MSF_SSOL_LIDAR_X(10),
    /**
     * <code>MSF_SSOL_LIDAR_XX = 11;</code>
     */
    MSF_SSOL_LIDAR_XX(11),
    /**
     * <code>MSF_SSOL_LIDAR_XXX = 12;</code>
     */
    MSF_SSOL_LIDAR_XXX(12),
    /**
     * <code>MSF_SSOL_X_X = 13;</code>
     */
    MSF_SSOL_X_X(13),
    /**
     * <code>MSF_SSOL_X_XX = 14;</code>
     */
    MSF_SSOL_X_XX(14),
    /**
     * <code>MSF_SSOL_X_XXX = 15;</code>
     */
    MSF_SSOL_X_XXX(15),
    /**
     * <code>MSF_NOSOL_LIDAR_GNSS = 16;</code>
     */
    MSF_NOSOL_LIDAR_GNSS(16),
    /**
     * <code>MSF_NOSOL_X_GNSS = 17;</code>
     */
    MSF_NOSOL_X_GNSS(17),
    /**
     * <code>MSF_NOSOL_LIDAR_X = 18;</code>
     */
    MSF_NOSOL_LIDAR_X(18),
    /**
     * <code>MSF_NOSOL_LIDAR_XX = 19;</code>
     */
    MSF_NOSOL_LIDAR_XX(19),
    /**
     * <code>MSF_NOSOL_LIDAR_XXX = 20;</code>
     */
    MSF_NOSOL_LIDAR_XXX(20),
    /**
     * <code>MSF_NOSOL_X_X = 21;</code>
     */
    MSF_NOSOL_X_X(21),
    /**
     * <code>MSF_NOSOL_X_XX = 22;</code>
     */
    MSF_NOSOL_X_XX(22),
    /**
     * <code>MSF_NOSOL_X_XXX = 23;</code>
     */
    MSF_NOSOL_X_XXX(23),
    /**
     * <code>MSF_RUNNING_INIT = 24;</code>
     */
    MSF_RUNNING_INIT(24),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MsfRunningStatus.class.getName());
    }
    /**
     * <code>MSF_SOL_LIDAR_GNSS = 0;</code>
     */
    public static final int MSF_SOL_LIDAR_GNSS_VALUE = 0;
    /**
     * <code>MSF_SOL_X_GNSS = 1;</code>
     */
    public static final int MSF_SOL_X_GNSS_VALUE = 1;
    /**
     * <code>MSF_SOL_LIDAR_X = 2;</code>
     */
    public static final int MSF_SOL_LIDAR_X_VALUE = 2;
    /**
     * <code>MSF_SOL_LIDAR_XX = 3;</code>
     */
    public static final int MSF_SOL_LIDAR_XX_VALUE = 3;
    /**
     * <code>MSF_SOL_LIDAR_XXX = 4;</code>
     */
    public static final int MSF_SOL_LIDAR_XXX_VALUE = 4;
    /**
     * <code>MSF_SOL_X_X = 5;</code>
     */
    public static final int MSF_SOL_X_X_VALUE = 5;
    /**
     * <code>MSF_SOL_X_XX = 6;</code>
     */
    public static final int MSF_SOL_X_XX_VALUE = 6;
    /**
     * <code>MSF_SOL_X_XXX = 7;</code>
     */
    public static final int MSF_SOL_X_XXX_VALUE = 7;
    /**
     * <code>MSF_SSOL_LIDAR_GNSS = 8;</code>
     */
    public static final int MSF_SSOL_LIDAR_GNSS_VALUE = 8;
    /**
     * <code>MSF_SSOL_X_GNSS = 9;</code>
     */
    public static final int MSF_SSOL_X_GNSS_VALUE = 9;
    /**
     * <code>MSF_SSOL_LIDAR_X = 10;</code>
     */
    public static final int MSF_SSOL_LIDAR_X_VALUE = 10;
    /**
     * <code>MSF_SSOL_LIDAR_XX = 11;</code>
     */
    public static final int MSF_SSOL_LIDAR_XX_VALUE = 11;
    /**
     * <code>MSF_SSOL_LIDAR_XXX = 12;</code>
     */
    public static final int MSF_SSOL_LIDAR_XXX_VALUE = 12;
    /**
     * <code>MSF_SSOL_X_X = 13;</code>
     */
    public static final int MSF_SSOL_X_X_VALUE = 13;
    /**
     * <code>MSF_SSOL_X_XX = 14;</code>
     */
    public static final int MSF_SSOL_X_XX_VALUE = 14;
    /**
     * <code>MSF_SSOL_X_XXX = 15;</code>
     */
    public static final int MSF_SSOL_X_XXX_VALUE = 15;
    /**
     * <code>MSF_NOSOL_LIDAR_GNSS = 16;</code>
     */
    public static final int MSF_NOSOL_LIDAR_GNSS_VALUE = 16;
    /**
     * <code>MSF_NOSOL_X_GNSS = 17;</code>
     */
    public static final int MSF_NOSOL_X_GNSS_VALUE = 17;
    /**
     * <code>MSF_NOSOL_LIDAR_X = 18;</code>
     */
    public static final int MSF_NOSOL_LIDAR_X_VALUE = 18;
    /**
     * <code>MSF_NOSOL_LIDAR_XX = 19;</code>
     */
    public static final int MSF_NOSOL_LIDAR_XX_VALUE = 19;
    /**
     * <code>MSF_NOSOL_LIDAR_XXX = 20;</code>
     */
    public static final int MSF_NOSOL_LIDAR_XXX_VALUE = 20;
    /**
     * <code>MSF_NOSOL_X_X = 21;</code>
     */
    public static final int MSF_NOSOL_X_X_VALUE = 21;
    /**
     * <code>MSF_NOSOL_X_XX = 22;</code>
     */
    public static final int MSF_NOSOL_X_XX_VALUE = 22;
    /**
     * <code>MSF_NOSOL_X_XXX = 23;</code>
     */
    public static final int MSF_NOSOL_X_XXX_VALUE = 23;
    /**
     * <code>MSF_RUNNING_INIT = 24;</code>
     */
    public static final int MSF_RUNNING_INIT_VALUE = 24;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static MsfRunningStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static MsfRunningStatus forNumber(int value) {
      switch (value) {
        case 0: return MSF_SOL_LIDAR_GNSS;
        case 1: return MSF_SOL_X_GNSS;
        case 2: return MSF_SOL_LIDAR_X;
        case 3: return MSF_SOL_LIDAR_XX;
        case 4: return MSF_SOL_LIDAR_XXX;
        case 5: return MSF_SOL_X_X;
        case 6: return MSF_SOL_X_XX;
        case 7: return MSF_SOL_X_XXX;
        case 8: return MSF_SSOL_LIDAR_GNSS;
        case 9: return MSF_SSOL_X_GNSS;
        case 10: return MSF_SSOL_LIDAR_X;
        case 11: return MSF_SSOL_LIDAR_XX;
        case 12: return MSF_SSOL_LIDAR_XXX;
        case 13: return MSF_SSOL_X_X;
        case 14: return MSF_SSOL_X_XX;
        case 15: return MSF_SSOL_X_XXX;
        case 16: return MSF_NOSOL_LIDAR_GNSS;
        case 17: return MSF_NOSOL_X_GNSS;
        case 18: return MSF_NOSOL_LIDAR_X;
        case 19: return MSF_NOSOL_LIDAR_XX;
        case 20: return MSF_NOSOL_LIDAR_XXX;
        case 21: return MSF_NOSOL_X_X;
        case 22: return MSF_NOSOL_X_XX;
        case 23: return MSF_NOSOL_X_XXX;
        case 24: return MSF_RUNNING_INIT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MsfRunningStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        MsfRunningStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MsfRunningStatus>() {
            public MsfRunningStatus findValueByNumber(int number) {
              return MsfRunningStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.getDescriptor().getEnumTypes().get(8);
    }

    private static final MsfRunningStatus[] VALUES = values();

    public static MsfRunningStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private MsfRunningStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:apollo.localization.MsfRunningStatus)
  }

  public interface MsfSensorMsgStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:apollo.localization.MsfSensorMsgStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
     * @return Whether the imuDelayStatus field is set.
     */
    boolean hasImuDelayStatus();
    /**
     * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
     * @return The imuDelayStatus.
     */
    apollo.localization.LocalizationStatus.ImuMsgDelayStatus getImuDelayStatus();

    /**
     * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
     * @return Whether the imuMissingStatus field is set.
     */
    boolean hasImuMissingStatus();
    /**
     * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
     * @return The imuMissingStatus.
     */
    apollo.localization.LocalizationStatus.ImuMsgMissingStatus getImuMissingStatus();

    /**
     * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
     * @return Whether the imuDataStatus field is set.
     */
    boolean hasImuDataStatus();
    /**
     * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
     * @return The imuDataStatus.
     */
    apollo.localization.LocalizationStatus.ImuMsgDataStatus getImuDataStatus();
  }
  /**
   * <pre>
   * The status of sensor msg
   * </pre>
   *
   * Protobuf type {@code apollo.localization.MsfSensorMsgStatus}
   */
  public static final class MsfSensorMsgStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:apollo.localization.MsfSensorMsgStatus)
      MsfSensorMsgStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MsfSensorMsgStatus.class.getName());
    }
    // Use MsfSensorMsgStatus.newBuilder() to construct.
    private MsfSensorMsgStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MsfSensorMsgStatus() {
      imuDelayStatus_ = 0;
      imuMissingStatus_ = 0;
      imuDataStatus_ = 0;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfSensorMsgStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfSensorMsgStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              apollo.localization.LocalizationStatus.MsfSensorMsgStatus.class, apollo.localization.LocalizationStatus.MsfSensorMsgStatus.Builder.class);
    }

    private int bitField0_;
    public static final int IMU_DELAY_STATUS_FIELD_NUMBER = 1;
    private int imuDelayStatus_ = 0;
    /**
     * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
     * @return Whether the imuDelayStatus field is set.
     */
    @java.lang.Override public boolean hasImuDelayStatus() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
     * @return The imuDelayStatus.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.ImuMsgDelayStatus getImuDelayStatus() {
      apollo.localization.LocalizationStatus.ImuMsgDelayStatus result = apollo.localization.LocalizationStatus.ImuMsgDelayStatus.forNumber(imuDelayStatus_);
      return result == null ? apollo.localization.LocalizationStatus.ImuMsgDelayStatus.IMU_DELAY_NORMAL : result;
    }

    public static final int IMU_MISSING_STATUS_FIELD_NUMBER = 2;
    private int imuMissingStatus_ = 0;
    /**
     * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
     * @return Whether the imuMissingStatus field is set.
     */
    @java.lang.Override public boolean hasImuMissingStatus() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
     * @return The imuMissingStatus.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.ImuMsgMissingStatus getImuMissingStatus() {
      apollo.localization.LocalizationStatus.ImuMsgMissingStatus result = apollo.localization.LocalizationStatus.ImuMsgMissingStatus.forNumber(imuMissingStatus_);
      return result == null ? apollo.localization.LocalizationStatus.ImuMsgMissingStatus.IMU_MISSING_NORMAL : result;
    }

    public static final int IMU_DATA_STATUS_FIELD_NUMBER = 3;
    private int imuDataStatus_ = 0;
    /**
     * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
     * @return Whether the imuDataStatus field is set.
     */
    @java.lang.Override public boolean hasImuDataStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
     * @return The imuDataStatus.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.ImuMsgDataStatus getImuDataStatus() {
      apollo.localization.LocalizationStatus.ImuMsgDataStatus result = apollo.localization.LocalizationStatus.ImuMsgDataStatus.forNumber(imuDataStatus_);
      return result == null ? apollo.localization.LocalizationStatus.ImuMsgDataStatus.IMU_DATA_NORMAL : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, imuDelayStatus_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeEnum(2, imuMissingStatus_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeEnum(3, imuDataStatus_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, imuDelayStatus_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, imuMissingStatus_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, imuDataStatus_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof apollo.localization.LocalizationStatus.MsfSensorMsgStatus)) {
        return super.equals(obj);
      }
      apollo.localization.LocalizationStatus.MsfSensorMsgStatus other = (apollo.localization.LocalizationStatus.MsfSensorMsgStatus) obj;

      if (hasImuDelayStatus() != other.hasImuDelayStatus()) return false;
      if (hasImuDelayStatus()) {
        if (imuDelayStatus_ != other.imuDelayStatus_) return false;
      }
      if (hasImuMissingStatus() != other.hasImuMissingStatus()) return false;
      if (hasImuMissingStatus()) {
        if (imuMissingStatus_ != other.imuMissingStatus_) return false;
      }
      if (hasImuDataStatus() != other.hasImuDataStatus()) return false;
      if (hasImuDataStatus()) {
        if (imuDataStatus_ != other.imuDataStatus_) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasImuDelayStatus()) {
        hash = (37 * hash) + IMU_DELAY_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + imuDelayStatus_;
      }
      if (hasImuMissingStatus()) {
        hash = (37 * hash) + IMU_MISSING_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + imuMissingStatus_;
      }
      if (hasImuDataStatus()) {
        hash = (37 * hash) + IMU_DATA_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + imuDataStatus_;
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(apollo.localization.LocalizationStatus.MsfSensorMsgStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The status of sensor msg
     * </pre>
     *
     * Protobuf type {@code apollo.localization.MsfSensorMsgStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:apollo.localization.MsfSensorMsgStatus)
        apollo.localization.LocalizationStatus.MsfSensorMsgStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfSensorMsgStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfSensorMsgStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                apollo.localization.LocalizationStatus.MsfSensorMsgStatus.class, apollo.localization.LocalizationStatus.MsfSensorMsgStatus.Builder.class);
      }

      // Construct using apollo.localization.LocalizationStatus.MsfSensorMsgStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        imuDelayStatus_ = 0;
        imuMissingStatus_ = 0;
        imuDataStatus_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfSensorMsgStatus_descriptor;
      }

      @java.lang.Override
      public apollo.localization.LocalizationStatus.MsfSensorMsgStatus getDefaultInstanceForType() {
        return apollo.localization.LocalizationStatus.MsfSensorMsgStatus.getDefaultInstance();
      }

      @java.lang.Override
      public apollo.localization.LocalizationStatus.MsfSensorMsgStatus build() {
        apollo.localization.LocalizationStatus.MsfSensorMsgStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public apollo.localization.LocalizationStatus.MsfSensorMsgStatus buildPartial() {
        apollo.localization.LocalizationStatus.MsfSensorMsgStatus result = new apollo.localization.LocalizationStatus.MsfSensorMsgStatus(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(apollo.localization.LocalizationStatus.MsfSensorMsgStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.imuDelayStatus_ = imuDelayStatus_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.imuMissingStatus_ = imuMissingStatus_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.imuDataStatus_ = imuDataStatus_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof apollo.localization.LocalizationStatus.MsfSensorMsgStatus) {
          return mergeFrom((apollo.localization.LocalizationStatus.MsfSensorMsgStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(apollo.localization.LocalizationStatus.MsfSensorMsgStatus other) {
        if (other == apollo.localization.LocalizationStatus.MsfSensorMsgStatus.getDefaultInstance()) return this;
        if (other.hasImuDelayStatus()) {
          setImuDelayStatus(other.getImuDelayStatus());
        }
        if (other.hasImuMissingStatus()) {
          setImuMissingStatus(other.getImuMissingStatus());
        }
        if (other.hasImuDataStatus()) {
          setImuDataStatus(other.getImuDataStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.ImuMsgDelayStatus tmpValue =
                    apollo.localization.LocalizationStatus.ImuMsgDelayStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  imuDelayStatus_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 16: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.ImuMsgMissingStatus tmpValue =
                    apollo.localization.LocalizationStatus.ImuMsgMissingStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  imuMissingStatus_ = tmpRaw;
                  bitField0_ |= 0x00000002;
                }
                break;
              } // case 16
              case 24: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.ImuMsgDataStatus tmpValue =
                    apollo.localization.LocalizationStatus.ImuMsgDataStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(3, tmpRaw);
                } else {
                  imuDataStatus_ = tmpRaw;
                  bitField0_ |= 0x00000004;
                }
                break;
              } // case 24
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int imuDelayStatus_ = 0;
      /**
       * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
       * @return Whether the imuDelayStatus field is set.
       */
      @java.lang.Override public boolean hasImuDelayStatus() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
       * @return The imuDelayStatus.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.ImuMsgDelayStatus getImuDelayStatus() {
        apollo.localization.LocalizationStatus.ImuMsgDelayStatus result = apollo.localization.LocalizationStatus.ImuMsgDelayStatus.forNumber(imuDelayStatus_);
        return result == null ? apollo.localization.LocalizationStatus.ImuMsgDelayStatus.IMU_DELAY_NORMAL : result;
      }
      /**
       * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
       * @param value The imuDelayStatus to set.
       * @return This builder for chaining.
       */
      public Builder setImuDelayStatus(apollo.localization.LocalizationStatus.ImuMsgDelayStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        imuDelayStatus_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.ImuMsgDelayStatus imu_delay_status = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearImuDelayStatus() {
        bitField0_ = (bitField0_ & ~0x00000001);
        imuDelayStatus_ = 0;
        onChanged();
        return this;
      }

      private int imuMissingStatus_ = 0;
      /**
       * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
       * @return Whether the imuMissingStatus field is set.
       */
      @java.lang.Override public boolean hasImuMissingStatus() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
       * @return The imuMissingStatus.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.ImuMsgMissingStatus getImuMissingStatus() {
        apollo.localization.LocalizationStatus.ImuMsgMissingStatus result = apollo.localization.LocalizationStatus.ImuMsgMissingStatus.forNumber(imuMissingStatus_);
        return result == null ? apollo.localization.LocalizationStatus.ImuMsgMissingStatus.IMU_MISSING_NORMAL : result;
      }
      /**
       * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
       * @param value The imuMissingStatus to set.
       * @return This builder for chaining.
       */
      public Builder setImuMissingStatus(apollo.localization.LocalizationStatus.ImuMsgMissingStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        imuMissingStatus_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.ImuMsgMissingStatus imu_missing_status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearImuMissingStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        imuMissingStatus_ = 0;
        onChanged();
        return this;
      }

      private int imuDataStatus_ = 0;
      /**
       * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
       * @return Whether the imuDataStatus field is set.
       */
      @java.lang.Override public boolean hasImuDataStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
       * @return The imuDataStatus.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.ImuMsgDataStatus getImuDataStatus() {
        apollo.localization.LocalizationStatus.ImuMsgDataStatus result = apollo.localization.LocalizationStatus.ImuMsgDataStatus.forNumber(imuDataStatus_);
        return result == null ? apollo.localization.LocalizationStatus.ImuMsgDataStatus.IMU_DATA_NORMAL : result;
      }
      /**
       * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
       * @param value The imuDataStatus to set.
       * @return This builder for chaining.
       */
      public Builder setImuDataStatus(apollo.localization.LocalizationStatus.ImuMsgDataStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        imuDataStatus_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.ImuMsgDataStatus imu_data_status = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearImuDataStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        imuDataStatus_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:apollo.localization.MsfSensorMsgStatus)
    }

    // @@protoc_insertion_point(class_scope:apollo.localization.MsfSensorMsgStatus)
    private static final apollo.localization.LocalizationStatus.MsfSensorMsgStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new apollo.localization.LocalizationStatus.MsfSensorMsgStatus();
    }

    public static apollo.localization.LocalizationStatus.MsfSensorMsgStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MsfSensorMsgStatus>
        PARSER = new com.google.protobuf.AbstractParser<MsfSensorMsgStatus>() {
      @java.lang.Override
      public MsfSensorMsgStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MsfSensorMsgStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MsfSensorMsgStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public apollo.localization.LocalizationStatus.MsfSensorMsgStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MsfStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:apollo.localization.MsfStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
     * @return Whether the localLidarConsistency field is set.
     */
    boolean hasLocalLidarConsistency();
    /**
     * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
     * @return The localLidarConsistency.
     */
    apollo.localization.LocalizationStatus.LocalLidarConsistency getLocalLidarConsistency();

    /**
     * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
     * @return Whether the gnssConsistency field is set.
     */
    boolean hasGnssConsistency();
    /**
     * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
     * @return The gnssConsistency.
     */
    apollo.localization.LocalizationStatus.GnssConsistency getGnssConsistency();

    /**
     * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
     * @return Whether the localLidarStatus field is set.
     */
    boolean hasLocalLidarStatus();
    /**
     * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
     * @return The localLidarStatus.
     */
    apollo.localization.LocalizationStatus.LocalLidarStatus getLocalLidarStatus();

    /**
     * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
     * @return Whether the localLidarQuality field is set.
     */
    boolean hasLocalLidarQuality();
    /**
     * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
     * @return The localLidarQuality.
     */
    apollo.localization.LocalizationStatus.LocalLidarQuality getLocalLidarQuality();

    /**
     * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
     * @return Whether the gnssposPositionType field is set.
     */
    boolean hasGnssposPositionType();
    /**
     * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
     * @return The gnssposPositionType.
     */
    apollo.localization.LocalizationStatus.GnssPositionType getGnssposPositionType();

    /**
     * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
     * @return Whether the msfRunningStatus field is set.
     */
    boolean hasMsfRunningStatus();
    /**
     * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
     * @return The msfRunningStatus.
     */
    apollo.localization.LocalizationStatus.MsfRunningStatus getMsfRunningStatus();
  }
  /**
   * <pre>
   * The status of msf localization module
   * </pre>
   *
   * Protobuf type {@code apollo.localization.MsfStatus}
   */
  public static final class MsfStatus extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:apollo.localization.MsfStatus)
      MsfStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 26,
        /* patch= */ 1,
        /* suffix= */ "",
        MsfStatus.class.getName());
    }
    // Use MsfStatus.newBuilder() to construct.
    private MsfStatus(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private MsfStatus() {
      localLidarConsistency_ = 0;
      gnssConsistency_ = 0;
      localLidarStatus_ = 0;
      localLidarQuality_ = 0;
      gnssposPositionType_ = 0;
      msfRunningStatus_ = 0;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              apollo.localization.LocalizationStatus.MsfStatus.class, apollo.localization.LocalizationStatus.MsfStatus.Builder.class);
    }

    private int bitField0_;
    public static final int LOCAL_LIDAR_CONSISTENCY_FIELD_NUMBER = 1;
    private int localLidarConsistency_ = 0;
    /**
     * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
     * @return Whether the localLidarConsistency field is set.
     */
    @java.lang.Override public boolean hasLocalLidarConsistency() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
     * @return The localLidarConsistency.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.LocalLidarConsistency getLocalLidarConsistency() {
      apollo.localization.LocalizationStatus.LocalLidarConsistency result = apollo.localization.LocalizationStatus.LocalLidarConsistency.forNumber(localLidarConsistency_);
      return result == null ? apollo.localization.LocalizationStatus.LocalLidarConsistency.MSF_LOCAL_LIDAR_CONSISTENCY_00 : result;
    }

    public static final int GNSS_CONSISTENCY_FIELD_NUMBER = 2;
    private int gnssConsistency_ = 0;
    /**
     * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
     * @return Whether the gnssConsistency field is set.
     */
    @java.lang.Override public boolean hasGnssConsistency() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
     * @return The gnssConsistency.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.GnssConsistency getGnssConsistency() {
      apollo.localization.LocalizationStatus.GnssConsistency result = apollo.localization.LocalizationStatus.GnssConsistency.forNumber(gnssConsistency_);
      return result == null ? apollo.localization.LocalizationStatus.GnssConsistency.MSF_GNSS_CONSISTENCY_00 : result;
    }

    public static final int LOCAL_LIDAR_STATUS_FIELD_NUMBER = 3;
    private int localLidarStatus_ = 0;
    /**
     * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
     * @return Whether the localLidarStatus field is set.
     */
    @java.lang.Override public boolean hasLocalLidarStatus() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
     * @return The localLidarStatus.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.LocalLidarStatus getLocalLidarStatus() {
      apollo.localization.LocalizationStatus.LocalLidarStatus result = apollo.localization.LocalizationStatus.LocalLidarStatus.forNumber(localLidarStatus_);
      return result == null ? apollo.localization.LocalizationStatus.LocalLidarStatus.MSF_LOCAL_LIDAR_NORMAL : result;
    }

    public static final int LOCAL_LIDAR_QUALITY_FIELD_NUMBER = 4;
    private int localLidarQuality_ = 0;
    /**
     * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
     * @return Whether the localLidarQuality field is set.
     */
    @java.lang.Override public boolean hasLocalLidarQuality() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
     * @return The localLidarQuality.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.LocalLidarQuality getLocalLidarQuality() {
      apollo.localization.LocalizationStatus.LocalLidarQuality result = apollo.localization.LocalizationStatus.LocalLidarQuality.forNumber(localLidarQuality_);
      return result == null ? apollo.localization.LocalizationStatus.LocalLidarQuality.MSF_LOCAL_LIDAR_VERY_GOOD : result;
    }

    public static final int GNSSPOS_POSITION_TYPE_FIELD_NUMBER = 5;
    private int gnssposPositionType_ = 0;
    /**
     * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
     * @return Whether the gnssposPositionType field is set.
     */
    @java.lang.Override public boolean hasGnssposPositionType() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
     * @return The gnssposPositionType.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.GnssPositionType getGnssposPositionType() {
      apollo.localization.LocalizationStatus.GnssPositionType result = apollo.localization.LocalizationStatus.GnssPositionType.forNumber(gnssposPositionType_);
      return result == null ? apollo.localization.LocalizationStatus.GnssPositionType.NONE : result;
    }

    public static final int MSF_RUNNING_STATUS_FIELD_NUMBER = 6;
    private int msfRunningStatus_ = 0;
    /**
     * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
     * @return Whether the msfRunningStatus field is set.
     */
    @java.lang.Override public boolean hasMsfRunningStatus() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
     * @return The msfRunningStatus.
     */
    @java.lang.Override public apollo.localization.LocalizationStatus.MsfRunningStatus getMsfRunningStatus() {
      apollo.localization.LocalizationStatus.MsfRunningStatus result = apollo.localization.LocalizationStatus.MsfRunningStatus.forNumber(msfRunningStatus_);
      return result == null ? apollo.localization.LocalizationStatus.MsfRunningStatus.MSF_SOL_LIDAR_GNSS : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, localLidarConsistency_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeEnum(2, gnssConsistency_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeEnum(3, localLidarStatus_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeEnum(4, localLidarQuality_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeEnum(5, gnssposPositionType_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeEnum(6, msfRunningStatus_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, localLidarConsistency_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, gnssConsistency_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(3, localLidarStatus_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, localLidarQuality_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(5, gnssposPositionType_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, msfRunningStatus_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof apollo.localization.LocalizationStatus.MsfStatus)) {
        return super.equals(obj);
      }
      apollo.localization.LocalizationStatus.MsfStatus other = (apollo.localization.LocalizationStatus.MsfStatus) obj;

      if (hasLocalLidarConsistency() != other.hasLocalLidarConsistency()) return false;
      if (hasLocalLidarConsistency()) {
        if (localLidarConsistency_ != other.localLidarConsistency_) return false;
      }
      if (hasGnssConsistency() != other.hasGnssConsistency()) return false;
      if (hasGnssConsistency()) {
        if (gnssConsistency_ != other.gnssConsistency_) return false;
      }
      if (hasLocalLidarStatus() != other.hasLocalLidarStatus()) return false;
      if (hasLocalLidarStatus()) {
        if (localLidarStatus_ != other.localLidarStatus_) return false;
      }
      if (hasLocalLidarQuality() != other.hasLocalLidarQuality()) return false;
      if (hasLocalLidarQuality()) {
        if (localLidarQuality_ != other.localLidarQuality_) return false;
      }
      if (hasGnssposPositionType() != other.hasGnssposPositionType()) return false;
      if (hasGnssposPositionType()) {
        if (gnssposPositionType_ != other.gnssposPositionType_) return false;
      }
      if (hasMsfRunningStatus() != other.hasMsfRunningStatus()) return false;
      if (hasMsfRunningStatus()) {
        if (msfRunningStatus_ != other.msfRunningStatus_) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasLocalLidarConsistency()) {
        hash = (37 * hash) + LOCAL_LIDAR_CONSISTENCY_FIELD_NUMBER;
        hash = (53 * hash) + localLidarConsistency_;
      }
      if (hasGnssConsistency()) {
        hash = (37 * hash) + GNSS_CONSISTENCY_FIELD_NUMBER;
        hash = (53 * hash) + gnssConsistency_;
      }
      if (hasLocalLidarStatus()) {
        hash = (37 * hash) + LOCAL_LIDAR_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + localLidarStatus_;
      }
      if (hasLocalLidarQuality()) {
        hash = (37 * hash) + LOCAL_LIDAR_QUALITY_FIELD_NUMBER;
        hash = (53 * hash) + localLidarQuality_;
      }
      if (hasGnssposPositionType()) {
        hash = (37 * hash) + GNSSPOS_POSITION_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + gnssposPositionType_;
      }
      if (hasMsfRunningStatus()) {
        hash = (37 * hash) + MSF_RUNNING_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + msfRunningStatus_;
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static apollo.localization.LocalizationStatus.MsfStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static apollo.localization.LocalizationStatus.MsfStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static apollo.localization.LocalizationStatus.MsfStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(apollo.localization.LocalizationStatus.MsfStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The status of msf localization module
     * </pre>
     *
     * Protobuf type {@code apollo.localization.MsfStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:apollo.localization.MsfStatus)
        apollo.localization.LocalizationStatus.MsfStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                apollo.localization.LocalizationStatus.MsfStatus.class, apollo.localization.LocalizationStatus.MsfStatus.Builder.class);
      }

      // Construct using apollo.localization.LocalizationStatus.MsfStatus.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        localLidarConsistency_ = 0;
        gnssConsistency_ = 0;
        localLidarStatus_ = 0;
        localLidarQuality_ = 0;
        gnssposPositionType_ = 0;
        msfRunningStatus_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return apollo.localization.LocalizationStatus.internal_static_apollo_localization_MsfStatus_descriptor;
      }

      @java.lang.Override
      public apollo.localization.LocalizationStatus.MsfStatus getDefaultInstanceForType() {
        return apollo.localization.LocalizationStatus.MsfStatus.getDefaultInstance();
      }

      @java.lang.Override
      public apollo.localization.LocalizationStatus.MsfStatus build() {
        apollo.localization.LocalizationStatus.MsfStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public apollo.localization.LocalizationStatus.MsfStatus buildPartial() {
        apollo.localization.LocalizationStatus.MsfStatus result = new apollo.localization.LocalizationStatus.MsfStatus(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(apollo.localization.LocalizationStatus.MsfStatus result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.localLidarConsistency_ = localLidarConsistency_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.gnssConsistency_ = gnssConsistency_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.localLidarStatus_ = localLidarStatus_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.localLidarQuality_ = localLidarQuality_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.gnssposPositionType_ = gnssposPositionType_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.msfRunningStatus_ = msfRunningStatus_;
          to_bitField0_ |= 0x00000020;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof apollo.localization.LocalizationStatus.MsfStatus) {
          return mergeFrom((apollo.localization.LocalizationStatus.MsfStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(apollo.localization.LocalizationStatus.MsfStatus other) {
        if (other == apollo.localization.LocalizationStatus.MsfStatus.getDefaultInstance()) return this;
        if (other.hasLocalLidarConsistency()) {
          setLocalLidarConsistency(other.getLocalLidarConsistency());
        }
        if (other.hasGnssConsistency()) {
          setGnssConsistency(other.getGnssConsistency());
        }
        if (other.hasLocalLidarStatus()) {
          setLocalLidarStatus(other.getLocalLidarStatus());
        }
        if (other.hasLocalLidarQuality()) {
          setLocalLidarQuality(other.getLocalLidarQuality());
        }
        if (other.hasGnssposPositionType()) {
          setGnssposPositionType(other.getGnssposPositionType());
        }
        if (other.hasMsfRunningStatus()) {
          setMsfRunningStatus(other.getMsfRunningStatus());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.LocalLidarConsistency tmpValue =
                    apollo.localization.LocalizationStatus.LocalLidarConsistency.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  localLidarConsistency_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 16: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.GnssConsistency tmpValue =
                    apollo.localization.LocalizationStatus.GnssConsistency.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  gnssConsistency_ = tmpRaw;
                  bitField0_ |= 0x00000002;
                }
                break;
              } // case 16
              case 24: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.LocalLidarStatus tmpValue =
                    apollo.localization.LocalizationStatus.LocalLidarStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(3, tmpRaw);
                } else {
                  localLidarStatus_ = tmpRaw;
                  bitField0_ |= 0x00000004;
                }
                break;
              } // case 24
              case 32: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.LocalLidarQuality tmpValue =
                    apollo.localization.LocalizationStatus.LocalLidarQuality.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  localLidarQuality_ = tmpRaw;
                  bitField0_ |= 0x00000008;
                }
                break;
              } // case 32
              case 40: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.GnssPositionType tmpValue =
                    apollo.localization.LocalizationStatus.GnssPositionType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(5, tmpRaw);
                } else {
                  gnssposPositionType_ = tmpRaw;
                  bitField0_ |= 0x00000010;
                }
                break;
              } // case 40
              case 48: {
                int tmpRaw = input.readEnum();
                apollo.localization.LocalizationStatus.MsfRunningStatus tmpValue =
                    apollo.localization.LocalizationStatus.MsfRunningStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(6, tmpRaw);
                } else {
                  msfRunningStatus_ = tmpRaw;
                  bitField0_ |= 0x00000020;
                }
                break;
              } // case 48
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int localLidarConsistency_ = 0;
      /**
       * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
       * @return Whether the localLidarConsistency field is set.
       */
      @java.lang.Override public boolean hasLocalLidarConsistency() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
       * @return The localLidarConsistency.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.LocalLidarConsistency getLocalLidarConsistency() {
        apollo.localization.LocalizationStatus.LocalLidarConsistency result = apollo.localization.LocalizationStatus.LocalLidarConsistency.forNumber(localLidarConsistency_);
        return result == null ? apollo.localization.LocalizationStatus.LocalLidarConsistency.MSF_LOCAL_LIDAR_CONSISTENCY_00 : result;
      }
      /**
       * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
       * @param value The localLidarConsistency to set.
       * @return This builder for chaining.
       */
      public Builder setLocalLidarConsistency(apollo.localization.LocalizationStatus.LocalLidarConsistency value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        localLidarConsistency_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.LocalLidarConsistency local_lidar_consistency = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalLidarConsistency() {
        bitField0_ = (bitField0_ & ~0x00000001);
        localLidarConsistency_ = 0;
        onChanged();
        return this;
      }

      private int gnssConsistency_ = 0;
      /**
       * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
       * @return Whether the gnssConsistency field is set.
       */
      @java.lang.Override public boolean hasGnssConsistency() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
       * @return The gnssConsistency.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.GnssConsistency getGnssConsistency() {
        apollo.localization.LocalizationStatus.GnssConsistency result = apollo.localization.LocalizationStatus.GnssConsistency.forNumber(gnssConsistency_);
        return result == null ? apollo.localization.LocalizationStatus.GnssConsistency.MSF_GNSS_CONSISTENCY_00 : result;
      }
      /**
       * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
       * @param value The gnssConsistency to set.
       * @return This builder for chaining.
       */
      public Builder setGnssConsistency(apollo.localization.LocalizationStatus.GnssConsistency value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        gnssConsistency_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.GnssConsistency gnss_consistency = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearGnssConsistency() {
        bitField0_ = (bitField0_ & ~0x00000002);
        gnssConsistency_ = 0;
        onChanged();
        return this;
      }

      private int localLidarStatus_ = 0;
      /**
       * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
       * @return Whether the localLidarStatus field is set.
       */
      @java.lang.Override public boolean hasLocalLidarStatus() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
       * @return The localLidarStatus.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.LocalLidarStatus getLocalLidarStatus() {
        apollo.localization.LocalizationStatus.LocalLidarStatus result = apollo.localization.LocalizationStatus.LocalLidarStatus.forNumber(localLidarStatus_);
        return result == null ? apollo.localization.LocalizationStatus.LocalLidarStatus.MSF_LOCAL_LIDAR_NORMAL : result;
      }
      /**
       * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
       * @param value The localLidarStatus to set.
       * @return This builder for chaining.
       */
      public Builder setLocalLidarStatus(apollo.localization.LocalizationStatus.LocalLidarStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000004;
        localLidarStatus_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.LocalLidarStatus local_lidar_status = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalLidarStatus() {
        bitField0_ = (bitField0_ & ~0x00000004);
        localLidarStatus_ = 0;
        onChanged();
        return this;
      }

      private int localLidarQuality_ = 0;
      /**
       * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
       * @return Whether the localLidarQuality field is set.
       */
      @java.lang.Override public boolean hasLocalLidarQuality() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
       * @return The localLidarQuality.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.LocalLidarQuality getLocalLidarQuality() {
        apollo.localization.LocalizationStatus.LocalLidarQuality result = apollo.localization.LocalizationStatus.LocalLidarQuality.forNumber(localLidarQuality_);
        return result == null ? apollo.localization.LocalizationStatus.LocalLidarQuality.MSF_LOCAL_LIDAR_VERY_GOOD : result;
      }
      /**
       * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
       * @param value The localLidarQuality to set.
       * @return This builder for chaining.
       */
      public Builder setLocalLidarQuality(apollo.localization.LocalizationStatus.LocalLidarQuality value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000008;
        localLidarQuality_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.LocalLidarQuality local_lidar_quality = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLocalLidarQuality() {
        bitField0_ = (bitField0_ & ~0x00000008);
        localLidarQuality_ = 0;
        onChanged();
        return this;
      }

      private int gnssposPositionType_ = 0;
      /**
       * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
       * @return Whether the gnssposPositionType field is set.
       */
      @java.lang.Override public boolean hasGnssposPositionType() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
       * @return The gnssposPositionType.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.GnssPositionType getGnssposPositionType() {
        apollo.localization.LocalizationStatus.GnssPositionType result = apollo.localization.LocalizationStatus.GnssPositionType.forNumber(gnssposPositionType_);
        return result == null ? apollo.localization.LocalizationStatus.GnssPositionType.NONE : result;
      }
      /**
       * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
       * @param value The gnssposPositionType to set.
       * @return This builder for chaining.
       */
      public Builder setGnssposPositionType(apollo.localization.LocalizationStatus.GnssPositionType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        gnssposPositionType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.GnssPositionType gnsspos_position_type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearGnssposPositionType() {
        bitField0_ = (bitField0_ & ~0x00000010);
        gnssposPositionType_ = 0;
        onChanged();
        return this;
      }

      private int msfRunningStatus_ = 0;
      /**
       * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
       * @return Whether the msfRunningStatus field is set.
       */
      @java.lang.Override public boolean hasMsfRunningStatus() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
       * @return The msfRunningStatus.
       */
      @java.lang.Override
      public apollo.localization.LocalizationStatus.MsfRunningStatus getMsfRunningStatus() {
        apollo.localization.LocalizationStatus.MsfRunningStatus result = apollo.localization.LocalizationStatus.MsfRunningStatus.forNumber(msfRunningStatus_);
        return result == null ? apollo.localization.LocalizationStatus.MsfRunningStatus.MSF_SOL_LIDAR_GNSS : result;
      }
      /**
       * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
       * @param value The msfRunningStatus to set.
       * @return This builder for chaining.
       */
      public Builder setMsfRunningStatus(apollo.localization.LocalizationStatus.MsfRunningStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        msfRunningStatus_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .apollo.localization.MsfRunningStatus msf_running_status = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsfRunningStatus() {
        bitField0_ = (bitField0_ & ~0x00000020);
        msfRunningStatus_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:apollo.localization.MsfStatus)
    }

    // @@protoc_insertion_point(class_scope:apollo.localization.MsfStatus)
    private static final apollo.localization.LocalizationStatus.MsfStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new apollo.localization.LocalizationStatus.MsfStatus();
    }

    public static apollo.localization.LocalizationStatus.MsfStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MsfStatus>
        PARSER = new com.google.protobuf.AbstractParser<MsfStatus>() {
      @java.lang.Override
      public MsfStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MsfStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MsfStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public apollo.localization.LocalizationStatus.MsfStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_apollo_localization_MsfSensorMsgStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_apollo_localization_MsfSensorMsgStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_apollo_localization_MsfStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_apollo_localization_MsfStatus_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n4modules/localization/proto/localizatio" +
      "n_status.proto\022\023apollo.localization\"\334\001\n\022" +
      "MsfSensorMsgStatus\022@\n\020imu_delay_status\030\001" +
      " \001(\0162&.apollo.localization.ImuMsgDelaySt" +
      "atus\022D\n\022imu_missing_status\030\002 \001(\0162(.apoll" +
      "o.localization.ImuMsgMissingStatus\022>\n\017im" +
      "u_data_status\030\003 \001(\0162%.apollo.localizatio" +
      "n.ImuMsgDataStatus\"\251\003\n\tMsfStatus\022K\n\027loca" +
      "l_lidar_consistency\030\001 \001(\0162*.apollo.local" +
      "ization.LocalLidarConsistency\022>\n\020gnss_co" +
      "nsistency\030\002 \001(\0162$.apollo.localization.Gn" +
      "ssConsistency\022A\n\022local_lidar_status\030\003 \001(" +
      "\0162%.apollo.localization.LocalLidarStatus" +
      "\022C\n\023local_lidar_quality\030\004 \001(\0162&.apollo.l" +
      "ocalization.LocalLidarQuality\022D\n\025gnsspos" +
      "_position_type\030\005 \001(\0162%.apollo.localizati" +
      "on.GnssPositionType\022A\n\022msf_running_statu" +
      "s\030\006 \001(\0162%.apollo.localization.MsfRunning" +
      "Status*\242\002\n\020LocalLidarStatus\022\032\n\026MSF_LOCAL" +
      "_LIDAR_NORMAL\020\000\022\037\n\033MSF_LOCAL_LIDAR_MAP_M" +
      "ISSING\020\001\022&\n\"MSF_LOCAL_LIDAR_EXTRINSICS_M" +
      "ISSING\020\002\022&\n\"MSF_LOCAL_LIDAR_MAP_LOADING_" +
      "FAILED\020\003\022\035\n\031MSF_LOCAL_LIDAR_NO_OUTPUT\020\004\022" +
      "\036\n\032MSF_LOCAL_LIDAR_OUT_OF_MAP\020\005\022\034\n\030MSF_L" +
      "OCAL_LIDAR_NOT_GOOD\020\006\022$\n MSF_LOCAL_LIDAR" +
      "_UNDEFINED_STATUS\020\007*\202\001\n\021LocalLidarQualit" +
      "y\022\035\n\031MSF_LOCAL_LIDAR_VERY_GOOD\020\000\022\030\n\024MSF_" +
      "LOCAL_LIDAR_GOOD\020\001\022\033\n\027MSF_LOCAL_LIDAR_NO" +
      "T_BAD\020\002\022\027\n\023MSF_LOCAL_LIDAR_BAD\020\003*\247\001\n\025Loc" +
      "alLidarConsistency\022\"\n\036MSF_LOCAL_LIDAR_CO" +
      "NSISTENCY_00\020\000\022\"\n\036MSF_LOCAL_LIDAR_CONSIS" +
      "TENCY_01\020\001\022\"\n\036MSF_LOCAL_LIDAR_CONSISTENC" +
      "Y_02\020\002\022\"\n\036MSF_LOCAL_LIDAR_CONSISTENCY_03" +
      "\020\003*\205\001\n\017GnssConsistency\022\033\n\027MSF_GNSS_CONSI" +
      "STENCY_00\020\000\022\033\n\027MSF_GNSS_CONSISTENCY_01\020\001" +
      "\022\033\n\027MSF_GNSS_CONSISTENCY_02\020\002\022\033\n\027MSF_GNS" +
      "S_CONSISTENCY_03\020\003*\261\004\n\020GnssPositionType\022" +
      "\010\n\004NONE\020\000\022\014\n\010FIXEDPOS\020\001\022\017\n\013FIXEDHEIGHT\020\002" +
      "\022\r\n\tFLOATCONV\020\004\022\014\n\010WIDELANE\020\005\022\016\n\nNARROWL" +
      "ANE\020\006\022\024\n\020DOPPLER_VELOCITY\020\010\022\n\n\006SINGLE\020\020\022" +
      "\013\n\007PSRDIFF\020\021\022\010\n\004WAAS\020\022\022\016\n\nPROPOGATED\020\023\022\014" +
      "\n\010OMNISTAR\020\024\022\014\n\010L1_FLOAT\020 \022\022\n\016IONOFREE_F" +
      "LOAT\020!\022\020\n\014NARROW_FLOAT\020\"\022\n\n\006L1_INT\0200\022\014\n\010" +
      "WIDE_INT\0201\022\016\n\nNARROW_INT\0202\022\022\n\016RTK_DIRECT" +
      "_INS\0203\022\014\n\010INS_SBAS\0204\022\r\n\tINS_PSRSP\0205\022\017\n\013I" +
      "NS_PSRDIFF\0206\022\020\n\014INS_RTKFLOAT\0207\022\020\n\014INS_RT" +
      "KFIXED\0208\022\020\n\014INS_OMNISTAR\0209\022\023\n\017INS_OMNIST" +
      "AR_HP\020:\022\023\n\017INS_OMNISTAR_XP\020;\022\017\n\013OMNISTAR" +
      "_HP\020@\022\017\n\013OMNISTAR_XP\020A\022\022\n\016PPP_CONVERGING" +
      "\020D\022\007\n\003PPP\020E\022\026\n\022INS_PPP_Converging\020I\022\013\n\007I" +
      "NS_PPP\020J\022\014\n\010MSG_LOSS\020[*t\n\021ImuMsgDelaySta" +
      "tus\022\024\n\020IMU_DELAY_NORMAL\020\000\022\017\n\013IMU_DELAY_1" +
      "\020\001\022\017\n\013IMU_DELAY_2\020\002\022\017\n\013IMU_DELAY_3\020\003\022\026\n\022" +
      "IMU_DELAY_ABNORMAL\020\004*\246\001\n\023ImuMsgMissingSt" +
      "atus\022\026\n\022IMU_MISSING_NORMAL\020\000\022\021\n\rIMU_MISS" +
      "ING_1\020\001\022\021\n\rIMU_MISSING_2\020\002\022\021\n\rIMU_MISSIN" +
      "G_3\020\003\022\021\n\rIMU_MISSING_4\020\004\022\021\n\rIMU_MISSING_" +
      "5\020\005\022\030\n\024IMU_MISSING_ABNORMAL\020\006*R\n\020ImuMsgD" +
      "ataStatus\022\023\n\017IMU_DATA_NORMAL\020\000\022\025\n\021IMU_DA" +
      "TA_ABNORMAL\020\001\022\022\n\016IMU_DATA_OTHER\020\002*\254\004\n\020Ms" +
      "fRunningStatus\022\026\n\022MSF_SOL_LIDAR_GNSS\020\000\022\022" +
      "\n\016MSF_SOL_X_GNSS\020\001\022\023\n\017MSF_SOL_LIDAR_X\020\002\022" +
      "\024\n\020MSF_SOL_LIDAR_XX\020\003\022\025\n\021MSF_SOL_LIDAR_X" +
      "XX\020\004\022\017\n\013MSF_SOL_X_X\020\005\022\020\n\014MSF_SOL_X_XX\020\006\022" +
      "\021\n\rMSF_SOL_X_XXX\020\007\022\027\n\023MSF_SSOL_LIDAR_GNS" +
      "S\020\010\022\023\n\017MSF_SSOL_X_GNSS\020\t\022\024\n\020MSF_SSOL_LID" +
      "AR_X\020\n\022\025\n\021MSF_SSOL_LIDAR_XX\020\013\022\026\n\022MSF_SSO" +
      "L_LIDAR_XXX\020\014\022\020\n\014MSF_SSOL_X_X\020\r\022\021\n\rMSF_S" +
      "SOL_X_XX\020\016\022\022\n\016MSF_SSOL_X_XXX\020\017\022\030\n\024MSF_NO" +
      "SOL_LIDAR_GNSS\020\020\022\024\n\020MSF_NOSOL_X_GNSS\020\021\022\025" +
      "\n\021MSF_NOSOL_LIDAR_X\020\022\022\026\n\022MSF_NOSOL_LIDAR" +
      "_XX\020\023\022\027\n\023MSF_NOSOL_LIDAR_XXX\020\024\022\021\n\rMSF_NO" +
      "SOL_X_X\020\025\022\022\n\016MSF_NOSOL_X_XX\020\026\022\023\n\017MSF_NOS" +
      "OL_X_XXX\020\027\022\024\n\020MSF_RUNNING_INIT\020\030"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_apollo_localization_MsfSensorMsgStatus_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_apollo_localization_MsfSensorMsgStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_apollo_localization_MsfSensorMsgStatus_descriptor,
        new java.lang.String[] { "ImuDelayStatus", "ImuMissingStatus", "ImuDataStatus", });
    internal_static_apollo_localization_MsfStatus_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_apollo_localization_MsfStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_apollo_localization_MsfStatus_descriptor,
        new java.lang.String[] { "LocalLidarConsistency", "GnssConsistency", "LocalLidarStatus", "LocalLidarQuality", "GnssposPositionType", "MsfRunningStatus", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
